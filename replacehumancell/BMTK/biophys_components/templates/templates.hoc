
begintemplate Cell_A
    //public append_sections
    public NumSoma
    NumSoma = 1
    public soma, dend, apic, axon// declares object soma is a public object that can be accessed by any procedures/functions
    	

    public all, somatic, basal, apical, axonal
    objref all,  somatic, basal, apical, axonal
    objref this

	create soma[NumSoma]	// declares soma as a membrane compartment object
	create dend[1]
	create apic[1]
    
    
    

	proc init() {
 	all = new SectionList()
	somatic = new SectionList()
	basal = new SectionList()
	apical = new SectionList()

	for i=0,NumSoma soma[i] { all.append()
            somatic.append()} 

	dend[0] all.append()
	apic[0] all.append()
	soma[0] somatic.append()
	dend[0] basal.append()
	apic[0] apical.append()


        	gUnf_Xsoma = 2.5e-05
		Rm = 80000 // decreased overall
		SpineScale = 1.76371308 //2
		SpineScale_leak = 1.763714578
		Cm = 2.4 // 1.8 // 2 //1
		RaAll= 150//200
		RaSoma= 150 // 146.969697
		RaDend = 150
		RaAxIs = 150//100//200
		Vpas = -72//-65//-70 // -67
		gna = 0.015 
		gnap = 0.000559 // 0.000551 
		gkdr = 0.002 //0.002 
		ghd = 1.5e-5 //1.5e-5
		gca = 5.5e-4 
		gm = 0.00224 // 0.00222  
		gsAHP = 0.05//0.0019
		gkap = 0.002 
		gleak = 2.5e-5
		gleak_dend=1.57*3.0e-5
			
		nash=10
		Vrest = -70
		celsius = 31.0 


        /////// topology ////////

		connect dend[0](0), soma[0](0)

        	connect apic[0](0), soma[0](1)




                	
		/////// geometrical properties //////
		soma[0] {L = 25 diam = 24.75 nseg = 1}		//{L = 20 diam = 20 nseg = 13}
	    	dend[0] {diam= 3 L=270 nseg=8}     // 3.5
		apic[0] {diam =5 L=555 nseg=7} 
        
        
	
	//access soma[0]	

	apic[0] {
				insert cadyn gcabar_cadyn = gca eca = 120
				insert leak el_leak = -72  glbar_leak = gleak_dend Ra=RaDend cm = Cm // 2.5
				insert hd ghdbar_hd = ghd 
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
				insert nap gbar_nap = 0  gbar_nap(1/(2*nseg)) = 0.8*gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 
				insert sAHP gsAHPbar_sAHP = 0
				insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 0.8*gm
				insert kap gkabar_kap = 0
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000-555/2
				
				
								
		}		
		soma[0] {	
				insert cadyn gcabar_cadyn = gca  eca = 120
				insert leak el_leak= -72  glbar_leak = 1.0*gleak   Ra=RaSoma cm = Cm // 2.5
				insert hd ghdbar_hd = ghd 
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = 3*gna
				insert nap gbar_nap = gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 //only in dend and p_dend
				insert sAHP gsAHPbar_sAHP = gsAHP
				insert im gbar_im = gm
				insert kap gkabar_kap = gkap
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000
				
				
		//drv = new IClamp(0.5)
		//drv.del = 0
		//drv.dur = tstop
		//drv.amp = 0.0//0.2  //nA
		
				
		}	
		
		dend[0] {  // need to add Spine Scale
				insert cadyn gcabar_cadyn = gca  eca = 120
				insert leak el_leak= -72  glbar_leak = gleak_dend  Ra=RaAll cm = Cm // 2.5
				insert hd ghdbar_hd = ghd
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
				insert nap gbar_nap = 0 gbar_nap(1/(2*nseg)) = 1.0*gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 
				insert sAHP gsAHPbar_sAHP = 0
				insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 1.0*gm
				insert kap gkabar_kap = gkap
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000+270/2
				
				
			}
		
		forall {
		  //insert extracellular
			v=Vrest
			ena = 45
			ek = -80
			if (ismembrane("kdr") || ismembrane("kap") || ismembrane("kad")) {ek=-80}
			if (ismembrane("hd") ) {ehd_hd=-45 } // change from -30 to -50
			
	
		}	
		



	//print x,r
	//        r = sqrt((x_xtra(x) - $1)^2 + (y_xtra(x) - $2)^2 + (z_xtra(x) - $3)^2)
        // 0.01 converts rho's cm to um and ohm to megohm
        // if electrode is exactly at a node, r will be 0
        // this would be meaningless since the location would be inside the cell
        // so force r to be at least as big as local radius
	
		
	

define_shape()
}
endtemplate Cell_A

//////////////////////////////////type C/////////////////////////


begintemplate Cell_C
    //public append_sections
    public NumSoma
    NumSoma = 1
    public soma, dend, apic, axon// declares object soma is a public object that can be accessed by any procedures/functions
    	

    public all, somatic, basal, apical, axonal
    objref all,  somatic, basal, apical, axonal
    objref this

	create soma[NumSoma]	// declares soma as a membrane compartment object
	create dend[1]
	create apic[1]
    
    
    

	proc init() {
 	all = new SectionList()
	somatic = new SectionList()
	basal = new SectionList()
	apical = new SectionList()

	for i=0,NumSoma soma[i] { all.append()
            somatic.append()} 

	dend[0] all.append()
	apic[0] all.append()
	soma[0] somatic.append()
	dend[0] basal.append()
	apic[0] apical.append()


        	gUnf_Xsoma = 2.5e-05
		Rm = 80000 // decreased overall
		SpineScale = 1.76371308 //2
		SpineScale_leak = 1.763714578
		Cm = 2.4 // 1.8 // 2 //1
		RaAll= 150//200
		RaSoma= 150 // 146.969697
		RaDend = 150
		RaAxIs = 150//100//200
		Vpas = -72//-65//-70 // -67
		gna = 0.015 
		gnap = 0.000559 // 0.000551 
		gkdr = 0.002 //0.002 
		ghd = 1.5e-5 //1.5e-5
		gca = 5.5e-4 
		gm = 0.00224 // 0.00222  
		gsAHP = 0.0002//0.0019
		gkap = 0.002 
		gleak = 2.5e-5
		gleak_dend=1.57*3.0e-5
			
		nash=10
		Vrest = -70
		celsius = 31.0 


        /////// topology ////////

		connect dend[0](0), soma[0](0)

        	connect apic[0](0), soma[0](1)




                	
		/////// geometrical properties //////
		soma[0] {L = 25 diam = 24.75 nseg = 1}		//{L = 20 diam = 20 nseg = 13}
	    	dend[0] {diam= 3 L=270 nseg=8}     // 3.5
		apic[0] {diam =5 L=555 nseg=7} 
        
        
	
	//access soma[0]	

	apic[0] {
				insert cadyn gcabar_cadyn = gca eca = 120
				insert leak el_leak = -72  glbar_leak = gleak_dend Ra=RaDend cm = Cm // 2.5
				insert hd ghdbar_hd = ghd 
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
				insert nap gbar_nap = 0  gbar_nap(1/(2*nseg)) = 0.8*gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 
				insert sAHP gsAHPbar_sAHP = 0
				insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 0.8*gm
				insert kap gkabar_kap = 0
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000-555/2
				
				
								
		}		
		soma[0] {	
				insert cadyn gcabar_cadyn = gca  eca = 120
				insert leak el_leak= -72  glbar_leak = 1.0*gleak   Ra=RaSoma cm = Cm // 2.5
				insert hd ghdbar_hd = ghd 
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = 3*gna
				insert nap gbar_nap = gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 //only in dend and p_dend
				insert sAHP gsAHPbar_sAHP = gsAHP
				insert im gbar_im = gm
				insert kap gkabar_kap = gkap
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000
				
				
		//drv = new IClamp(0.5)
		//drv.del = 0
		//drv.dur = tstop
		//drv.amp = 0.0//0.2  //nA
		
				
		}	
		
		dend[0] {  // need to add Spine Scale
				insert cadyn gcabar_cadyn = gca  eca = 120
				insert leak el_leak= -72  glbar_leak = gleak_dend  Ra=RaAll cm = Cm // 2.5
				insert hd ghdbar_hd = ghd
				insert na3 sh_na3=nash ar_na3=1	gbar_na3 = gna
				insert nap gbar_nap = 0 gbar_nap(1/(2*nseg)) = 1.0*gnap
				insert kdr gbar_kdr = gkdr
				insert capool taucas = 1000  fcas_capool = 0.05 
				insert sAHP gsAHPbar_sAHP = 0
				insert im gbar_im = 0 gbar_im(1/(2*nseg)) = 1.0*gm
				insert kap gkabar_kap = gkap
				//insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000+270/2
				
				
			}
		
		forall {
		  //insert extracellular
			v=Vrest
			ena = 45
			ek = -80
			if (ismembrane("kdr") || ismembrane("kap") || ismembrane("kad")) {ek=-80}
			if (ismembrane("hd") ) {ehd_hd=-45 } // change from -30 to -50
			
	
		}	
		



	//print x,r
	//        r = sqrt((x_xtra(x) - $1)^2 + (y_xtra(x) - $2)^2 + (z_xtra(x) - $3)^2)
        // 0.01 converts rho's cm to um and ohm to megohm
        // if electrode is exactly at a node, r will be 0
        // this would be meaningless since the location would be inside the cell
        // so force r to be at least as big as local radius
	
		
	

define_shape()
}
endtemplate Cell_C


//////////////////PN cells//////////////////

begintemplate Cell_PN
    public type,LFPtemp_xtra,drv,append_sections,all,set_nseg,connect2target
    public init, connect_sections, insert_mechs,connect_gap
    public mechinit, set_biophys, get_root
    public pre_list, connect_pre, is_art, is_connected, gid, randi
    public soma, dend, apic, axon
    public all, soma_list, axon_list, dendrite_list
    public all, somatic, basal, apical, axonal
    public Vrest
    objref tlist, area_vec
	public tlist, area_vec
    strdef type
    objref gaps[200],drv
    // objects
    objref syn, pre_list, templist, rootlist, myrootsec, this, rr, rotation
    objref this
    // external variables
    //external numCellTypes, cellType, VClampVector

    create soma[1]
    create dend[1]
    //create apic[1]
    //create axon[12]
    proc init(){
        tlist = new List()
    	area_vec = new Vector()	
        type = "InterneuronCell"
        connect_sections()
        define_shape()	
        append_sections()
        set_nseg()
        insert_mechs()
        //connect_gap()
        //connect2target()
       
    }

    proc connect_sections(){
        connect dend[0](0), soma[0](1)
    }
objref all, somatic,axonal,basal,apical
    proc append_sections() { local i
        objref all, somatic,axonal,basal,apical

        all = new SectionList()
        somatic = new SectionList()
        axonal = new SectionList()
        basal = new SectionList()
        apical = new SectionList()
        
        soma all.append()
        soma somatic.append()
        
        dend[0] all.append()
        dend[0] basal.append()
    }

    proc set_nseg() {
        soma[0] {
                nseg=1
                L=15		// (micrometer)
                diam=15		// (micrometer)
                }

            dend[0] {
                nseg=1
                L=150		// (micrometer)
                diam=10		// (micrometer)
            }	
    }

    proc insert_mechs(){

        soma[0]{
            cm = 1//1		    // (microF/cm2)
            Ra = 150*22.5	// (ohm-cm)
            Rm = 20000	    // (ohm-cm2)
            
            insert leakinter
            glbar_inter_leakinter = 1/Rm // (siemens/cm2)
            el_leakinter = -70	// (mV)

            insert nainter
            insert kdrinter
            ena = 45		// (mV)
            gnabar_nainter = 0.035	// (siemens/cm2)

            ek = -80		// (mV)
            gkdrbar_kdrinter = 0.008 // (siemens/cm2)
            
            /*for i=0,199 { 
            gaps[i] = new gap(0.5) 
            gaps[i].r = 1500//100000//100000 // Mohm resistance corresponding to 0.01 nS conductance
                    // that correspondes to 1nS for a cells of ~10000 â€˜my surface  
                    // order of magn. that was measured experimentally 
                    // ** 0.01 mS/cmy

            
            setpointer gaps[i].vgap,v(0.5)
            }*/
            //n_gaps=0
            //insert xtraimemrec	//x_xtra=$1*1000 y_xtra=$2*1000 z_xtra=$3*1000
        }

        dend[0]{
            cm = 1//1		// (microF/cm2)
            Ra = 150	// (ohm-cm)
            Rm = 20000	// (ohm-cm2)
            
            insert leakinter
            glbar_inter_leakinter = 1/Rm // (siemens/cm2)
            el_leakinter = -70	// (mV)

            insert nainter
            insert kdrinter
            ena = 45		// (mV)
            gnabar_nainter = 0.010	// (siemens/cm2)

            ek = -80		// (mV)
            gkdrbar_kdrinter = 0.003 // (siemens/cm2)
            
            insert ca_ion
            eca = 120
            //insert xtraimemrec
        }

        forall {
            insert extracellular
            for (x, 0) {
            if (ismembrane("xtraimemrec")) {
                        //print x
                        setpointer im_xtraimemrec(x), i_membrane(x)
                        setpointer ex_xtraimemrec(x), e_extracellular(x)
                    }
                }
                
            //for (x,0){
                //tlist.append(new Vector())
                //int_tlist.append(new Vector()) //now int_tlist is necessarily the same length as tlist
                //area_vec.append(area(x)) // area_vec.x(i) is area of tlist.o(i)
                //print area(x)
                //tlist.o(tlist.count()-1).record(&i_membrane(x),1)
                //tlist.o(tlist.count()-1).record(&er_xtraimemrec(x),1)
            //}
        }
    }

    /*proc connect_gap() {
        // $o1 arg is the other Cell
        n_gaps +=1
        setpointer gaps[n_gaps-1].vgap, $o1.soma[0].v(0.5)
    }*/

    obfunc connect2target(){ localobj nc
	    soma[0] nc = new NetCon(&v(0.5), $o1)
	    nc.threshold = 0
	    if (numarg() == 2) ($o2 = nc)
	    return nc
    }
    init()
endtemplate Cell_PN



///////////////////////////////////
begintemplate Layer5_pyr
public NumSoma
NumSoma=1

public is_art
public init, topol, basic_shape, subsets, geom, biophys
public x, y, z, position, connect2target
public ampa,nmda,gabaa,gabab

public soma, dend
public all, somatic, dendritic, apical, basal, dend0, dend1, dend2, dend3
public dend4, dend5, dend6, dend7
// if gbar_x is declared as 'public', can not be set in biophys() below
// public gbar_ar, gbar_cat 

objref synlist

proc init() {
  topol()
  subsets()
  geom()
  biophys()
  geom_nseg()
  synlist = new List()
  synapses()
  x = y = z = 0 // only change via position
}

create soma[NumSoma], dend[8]

proc topol() { local i
  connect dend(0), soma(1)
  for i = 1, 2 connect dend[i](0), dend(1)
  for i = 3, 4 connect dend[i](0), dend[i-1](1)
  connect dend[5](0), soma(0) //was soma(1)this is correct! 
  for i = 6, 7 connect dend[i](0), dend[5](1)
  basic_shape()
}

 proc basic_shape() {
// THESE AND LENGHTHS MUST CHANGE TOGETHER!!!
  soma {pt3dclear() pt3dadd(0, 0, 0, 1) pt3dadd(0, 23, 0, 1)}
  dend {pt3dclear() pt3dadd(0, 23, 0, 1) pt3dadd(0, 83, 0, 1)}
  dend[1] {pt3dclear() pt3dadd(0, 83, 0, 1) pt3dadd(-150, 83, 0, 1)}
  dend[2] {pt3dclear() pt3dadd(0, 83, 0, 1) pt3dadd(0, 483, 0, 1)}
  dend[3] {pt3dclear() pt3dadd(0, 483, 0, 1) pt3dadd(0, 883, 0, 1)}
  dend[4] {pt3dclear() pt3dadd(0, 883, 0, 1) pt3dadd(0, 1133, 0, 1)}
  dend[5] {pt3dclear() pt3dadd(0, 0, 0, 1) pt3dadd(0, -50, 0, 1)}
  dend[6] {pt3dclear() pt3dadd(0, -50, 0, 1) pt3dadd(-106, -156, 0, 1)}
  dend[7] {pt3dclear() pt3dadd(0, -50, 0, 1) pt3dadd(106, -156, 0, 1)}
} 

objref all, somatic, dendritic, apical, basal, dend0, dend1, dend2, dend3, dend4
objref dend5, dend6, dend7
proc subsets() { local i
  objref all, somatic, dendritic, apical, basal, dend0, dend1, dend2, dend3 
  objref dend4, dend5, dend6, dend7

  all = new SectionList()
  somatic = new SectionList()
   for i=0,NumSoma{ soma[i] all.append()
    

    soma[i] somatic.append()}

  for i=0, 7 dend[i] all.append()
  dendritic = new SectionList()
    for i=0, 7 dend[i] dendritic.append()

  apical = new SectionList()
    for i=0, 4 dend[i] apical.append()

  basal = new SectionList()
    for i=5, 7 dend[i] basal.append()

  dend0 = new SectionList()
	dend[0] dend0.append()

  dend1 = new SectionList()
	dend[1] dend1.append()

  dend2 = new SectionList()
	dend[2] dend2.append()

  dend3 = new SectionList()
	dend[3] dend3.append()

  dend4 = new SectionList()
	dend[4] dend4.append()

  dend5 = new SectionList()
	dend[5] dend5.append()

  dend6 = new SectionList()
	dend[6] dend6.append()

  dend7 = new SectionList()
	dend[7] dend7.append()


}
//increased lengths and diams by 70% for human size
proc geom() {
  forsec all {  }
    // soma.L = 13 //BUSH 1999 spike amp smaller
   soma[0].L=39 //Bush 1993
   dend[1].L = 102
   dend[1].L = 255
   dend[2].L = 680 //default 400
   dend[3].L = 680 //default 400
   dend[4].L = 425
   dend[5].L = 85
   dend[6].L = 255 // default 150
   dend[7].L = 255 // default 150
    //soma.diam = 18.95 //Bush 1999
   soma[0].diam = 28.9 //Bush 1993
   dend[1].diam = 10.2
   dend[1].diam = 5.1
   dend[2].diam = 7.48 //default 4.4
   dend[3].diam = 4.93 //default 2.9
   dend[4].diam = 3.4
   dend[5].diam = 6.8
   dend[6].diam = 8.5
   dend[7].diam = 8.5
}
proc geom_nseg() {
  soma area(.5) // make sure diam reflects 3d points
   forsec all { if (L < 50) {nseg=1} else {nseg=int(L/50)} }
}
proc biophys() {
/* USING DEFAULT NEURON HH GIVES CORRECT SPIKE WIDTH */
	forsec all{
		Ra=200
		cm=0.85 // decreased by 70%
		
	}
	forsec somatic {
		insert hh
		gnabar_hh=0.16 // to match latency with old segmentation
		gkbar_hh=0.01 //0.01 0.09 for spiking
		gl_hh=0.0000426 //decreased by 70%
		el_hh=-65 //default -65
		insert ca
		gbar_ca=60// 100 //150 pS/um2=0.00015 S/cm2
		insert cad
		taur_cad=20 //20 ms 
		insert kca
		gbar_kca=0.0002//0.0002 //(0.00015 mho/cm2= S/cm2)
		insert km
		gbar_km=200//200 //10 pS/um2
                insert cat
                gbar_cat=0.002
                insert ar
                gbar_ar=0.00006
	}
	forsec dendritic {
		insert hh
		gnabar_hh=0.14 //0.45 S/cm2
		gkbar_hh=0.01 //0.09 for spiking
		gl_hh=0.0000426
		el_hh=-71 //default -71
		insert ca
		gbar_ca=60//100 //15 pS/um2
		insert cad
		taur_cad=20 //20 ms 
		insert kca
		gbar_kca=0.0002//0.0002 //0.015(mho/cm2= S/cm2)
		insert km
		gbar_km=200//200 //10 pS/um2
                insert cat
                gbar_cat=0
                insert ar
                gbar_ar=0

	} 

 }  //end proc biophysics 
proc position() { local i
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
  }
  x = $1  y = $2  z = $3
}
proc connect2target() { //$o1 target point process, $o2 returned NetCon
  soma $o2 = new NetCon(&v(1), $o1)
}

objref ampa[9],nmda[9],gabaa[9],gabab[9]
//proc synapses() {
//  dend[0]{ ampa[0] = new AMPA() nmda[0] = new NMDA() gabaa[0] = new GABAA() gabab[0] = new GABAB() }
//  dend[1]{ ampa[1] = new AMPA() nmda[1] = new NMDA() gabaa[1] = new GABAA() gabab[1] = new GABAB() }           
//  dend[2]{ ampa[2] = new AMPA() nmda[2] = new NMDA() gabaa[2] = new GABAA() gabab[2] = new GABAB() }           
//  dend[3]{ ampa[3] = new AMPA() nmda[3] = new NMDA() gabaa[3] = new GABAA() gabab[3] = new GABAB() }           
//  dend[4]{ ampa[4] = new AMPA() nmda[4] = new NMDA() gabaa[4] = new GABAA() gabab[4] = new GABAB() }           
//  dend[5]{ ampa[5] = new AMPA() nmda[5] = new NMDA() gabaa[5] = new GABAA() gabab[5] = new GABAB() }           
//  dend[6]{ ampa[6] = new AMPA() nmda[6] = new NMDA() gabaa[6] = new GABAA() gabab[6] = new GABAB() }           
//  dend[7]{ ampa[7] = new AMPA() nmda[7] = new NMDA() gabaa[7] = new GABAA() gabab[7] = new GABAB() }           
//  soma[0]{ ampa[8] = new AMPA() nmda[8] = new NMDA() gabaa[8] = new GABAA() gabab[8] = new GABAB() }
//}

func is_art() { return 0 }

endtemplate Layer5_pyr


//////////////////////////////////////////////////////////////////////
begintemplate Layer2_pyr
public init, topol, basic_shape, subsets, geom, biophys
public synlist, x, y, z, position, connect2target
public ampa,nmda,gabaa,gabab

public soma, dend
public all, somatic, dendritic, apical, basal, dend0, dend1
public dend2, dend3, dend4, dend5, dend6 
public pre, ampa, gabaa, gabab, nmda
public gbar_ar, gbar_cat

objref synlist

proc init() {
  topol()
  subsets()
  geom()
  biophys()
  geom_nseg()
  synlist = new List()
  synapses()
  x = y = z = 0 // only change via position
}

create soma[0], dend[7]

proc topol() { local i
  connect dend(0), soma(1)
  for i = 1, 2 connect dend[i](0), dend(1)
  connect dend[3](0), dend[2](1)
  connect dend[4](0), soma[0](0) //was soma(1), 0 is correct!
  for i = 5, 6 connect dend[i](0), dend[4](1)
  basic_shape()
}
proc basic_shape() {
  soma[0] {pt3dclear() pt3dadd(-50, 765, 0, 1) pt3dadd(-50, 778, 0, 1)}
  dend[0] {pt3dclear() pt3dadd(-50, 778, 0, 1) pt3dadd(-50, 813, 0, 1)}
  dend[1] {pt3dclear() pt3dadd(-50, 813, 0, 1) pt3dadd(-250, 813, 0, 1)}
  dend[2] {pt3dclear() pt3dadd(-50, 813, 0, 1) pt3dadd(-50, 993, 0, 1)}
  dend[3] {pt3dclear() pt3dadd(-50, 993, 0, 1) pt3dadd(-50, 1133, 0, 1)}
  dend[4] {pt3dclear() pt3dadd(-50, 765, 0, 1) pt3dadd(-50, 715, 0, 1)}
  dend[5] {pt3dclear() pt3dadd(-50, 715, 0, 1) pt3dadd(-156, 609, 0, 1)}
  dend[6] {pt3dclear() pt3dadd(-50, 715, 0, 1) pt3dadd(56, 609, 0, 1)}
}

objref all, somatic, dendritic, apical, basal, dend0, dend1
objref dend2, dend3, dend4, dend5, dend6
proc subsets() { local i
  objref all, somatic, dendritic, apical, basal, dend0, dend1
  objref dend2, dend3, dend4, dend5, dend6
  all = new SectionList()
    soma all.append()
    for i=0, 6 dend[i] all.append()

  somatic = new SectionList()
    soma[0] somatic.append()

  dendritic = new SectionList()
    for i=0, 6 dend[i] dendritic.append()

  apical = new SectionList()
    for i=0, 3 dend[i] apical.append()

  basal = new SectionList()
    for i=4, 6 dend[i] basal.append()

  dend0 = new SectionList()
    dend[0] dend0.append()

  dend1 = new SectionList()
    dend[1] dend1.append()

  dend2 = new SectionList()
    dend[2] dend2.append()

  dend3 = new SectionList()
    dend[3] dend3.append()

  dend4 = new SectionList()
    dend[4] dend4.append()

  dend5 = new SectionList()
    dend[5] dend5.append()

  dend6 = new SectionList()
    dend[6] dend6.append()

}
// increased by 70% for human
proc geom() {
  forsec all {  }
   soma[0].L = 22.1
   dend[0].L = 59.5
   dend[1].L = 340
   dend[2].L = 306
   dend[3].L = 238
   dend[4].L = 85
   dend[5].L = 255
   dend[6].L = 255
   
    soma[0].diam = 23.4
    dend[0].diam = 4.25
    dend[1].diam = 3.91
    dend[2].diam = 4.08
    dend[3].diam = 3.4
    dend[4].diam = 4.25
    dend[5].diam = 2.72
    dend[6].diam = 2.72

}
proc geom_nseg() {
  soma[0] area(.5) // make sure diam reflects 3d points
   forsec all { if (L < 50) {nseg=1} else {nseg=int(L/50)} }
}
proc biophys() {
/* USING DEFAULT NEURON HH GIVES CORRECT SPIKE WIDTH */
 forsec all {
    Ra = 200
    cm = 0.6195 // decreased 70% from 2.065
	}
forsec somatic {
		insert hh
		gnabar_hh=0.18 // to match latency with old segmentation
		gkbar_hh=0.01 //0.09
		gl_hh=0.0000426 //decreased 70% for human
		el_hh=-65
		insert km
		gbar_km=250 //450 pS/um2
                insert cat
                gbar_cat=0.0
                insert ar
                gbar_ar=0.0

	}
	forsec dendritic {
		insert hh
		gnabar_hh=0.15//0.45 S/cm2
		gkbar_hh=0.01 //0.09
		gl_hh=0.0000426 
		el_hh=-65
		insert km
		gbar_km=250 //450 pS/um2 =uS/cm2
                insert cat
                gbar_cat=0.0
                insert ar
                gbar_ar=0.0

	} 

 }  //end proc biophysics 


proc position() { local i
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
  }
  x = $1  y = $2  z = $3
}
proc connect2target() { //$o1 target point process, $o2 returned NetCon
  soma $o2 = new NetCon(&v(1), $o1)
}

objref ampa[8],nmda[8],gabaa[8],gabab[8]
//proc synapses() {
//  dend[0]{ ampa[0] = new AMPA() nmda[0] = new NMDA() gabaa[0] = new GABAA() gabab[0] = new GABAB() }
//  dend[1]{ ampa[1] = new AMPA() nmda[1] = new NMDA() gabaa[1] = new GABAA() gabab[1] = new GABAB() }
//  dend[2]{ ampa[2] = new AMPA() nmda[2] = new NMDA() gabaa[2] = new GABAA() gabab[2] = new GABAB() }
//  dend[3]{ ampa[3] = new AMPA() nmda[3] = new NMDA() gabaa[3] = new GABAA() gabab[3] = new GABAB() }
//  dend[4]{ ampa[4] = new AMPA() nmda[4] = new NMDA() gabaa[4] = new GABAA() gabab[4] = new GABAB() }
//  dend[5]{ ampa[5] = new AMPA() nmda[5] = new NMDA() gabaa[5] = new GABAA() gabab[5] = new GABAB() }
//  dend[6]{ ampa[6] = new AMPA() nmda[6] = new NMDA() gabaa[6] = new GABAA() gabab[6] = new GABAB() }
//  soma[0]{ ampa[7] = new AMPA() nmda[7] = new NMDA() gabaa[7] = new GABAA() gabab[7] = new GABAB() }
//} 

func is_art() { return 0 }

endtemplate Layer2_pyr

//////////////////////////////////////////


begintemplate Inhib

 all = new SectionList()
 somatic = new SectionList()
 basal = new SectionList()
 apical = new SectionList()
 axonal = new SectionList()
  public soma
create soma[0]	// declares soma as a membrane compartment object

    
    
 	all = new SectionList()
	somatic = new SectionList()
	basal = new SectionList()
	apical = new SectionList()

	
   soma[0] somatic.append()

	

public cell,connect2target,init,ampa,nmda,gabaa,gabab
external AMPA,NMDA,GABAA,GABAB

objref ampa[1],nmda[1],gabaa[1],gabab[1]
create cell

proc init(){
  access  cell
                L=39
                diam=20
                Ra=200
                cm=0.85
                insert hh
synapses()
}

proc synapses() {
cell {
      ampa = new AMPA()
      nmda = new NMDA()
      gabaa = new GABAA()
      gabab = new GABAB()
     }
}

// proc connect2target() {
// $o2 = new NetCon(cell(0.5), $o1)
//proc connect2target() { //$o1 target point process, $o2 returned NetCon
//  cell $o2 = new NetCon(&v(1), $o1)
//}

define_shape()

endtemplate Inhib
